package com.bitdubai.fermat_cry_plugin.layer.crypto_vault.developer.bitdubai.version_1.structure;

import com.bitdubai.fermat_api.FermatException;
import com.bitdubai.fermat_api.layer.all_definition.events.EventSource;
import com.bitdubai.fermat_api.layer.all_definition.events.interfaces.FermatEvent;
import com.bitdubai.fermat_api.layer.all_definition.exceptions.InvalidParameterException;
import com.bitdubai.fermat_api.layer.all_definition.transaction_transference_protocol.ProtocolStatus;
import com.bitdubai.fermat_api.layer.all_definition.transaction_transference_protocol.crypto_transactions.CryptoStatus;
import com.bitdubai.fermat_api.layer.all_definition.transaction_transference_protocol.crypto_transactions.CryptoTransactionType;
import com.bitdubai.fermat_api.layer.osa_android.database_system.Database;
import com.bitdubai.fermat_api.layer.osa_android.database_system.DatabaseFilterType;
import com.bitdubai.fermat_api.layer.osa_android.database_system.DatabaseTable;
import com.bitdubai.fermat_api.layer.osa_android.database_system.DatabaseTableRecord;
import com.bitdubai.fermat_api.layer.osa_android.database_system.DatabaseTransaction;
import com.bitdubai.fermat_api.layer.osa_android.database_system.exceptions.CantInsertRecordException;
import com.bitdubai.fermat_api.layer.osa_android.database_system.exceptions.CantLoadTableToMemoryException;
import com.bitdubai.fermat_api.layer.osa_android.database_system.exceptions.CantUpdateRecordException;
import com.bitdubai.fermat_api.layer.osa_android.database_system.exceptions.DatabaseTransactionFailedException;
import com.bitdubai.fermat_cry_api.layer.definition.enums.EventType;
import com.bitdubai.fermat_cry_plugin.layer.crypto_vault.developer.bitdubai.version_1.utils.TransactionTypeAndCryptoStatus;
import com.bitdubai.fermat_pip_api.layer.platform_service.event_manager.interfaces.EventManager;
import com.bitdubai.fermat_cry_api.layer.crypto_vault.events.IncomingCryptoOnCryptoNetworkEvent;
import com.bitdubai.fermat_cry_plugin.layer.crypto_vault.developer.bitdubai.version_1.exceptions.CantExecuteQueryException;
import com.bitdubai.fermat_cry_plugin.layer.crypto_vault.developer.bitdubai.version_1.exceptions.UnexpectedResultReturnedFromDatabaseException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.UUID;

/**
 * Created by rodrigo on 2015.06.17..
 * Modified by lnacosta (laion.cj91@gmail.com) on 15/10/2015.
 */
public class CryptoVaultDatabaseActions {

    private final Database     database    ;
    private final EventManager eventManager;

    /**
     * Constructor with final params.
     */
    public CryptoVaultDatabaseActions(final Database     database    ,
                                      final EventManager eventManager){

        this.database     = database    ;
        this.eventManager = eventManager;
    }

    public void saveIncomingTransaction(final UUID   txId  ,
                                        final String txHash) throws CantExecuteQueryException      ,
                                                                    CantLoadTableToMemoryException {
        /**
         * I need to validate that this is not a transaction I already saved because it might be from a transaction
         * generated by our wallet.
         */
        try {

            DatabaseTable cryptoTxTable = database.getTable(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_NAME);

            cryptoTxTable.setStringFilter(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_HASH_COLUMN_NAME, txHash, DatabaseFilterType.EQUAL);
            cryptoTxTable.loadToMemory();

            if (cryptoTxTable.getRecords().isEmpty()){
                /**
                 * If this is not a transaction that we previously generated, then I will identify it as a new transaction.
                 */
                DatabaseTableRecord incomingTxRecord =  cryptoTxTable.getEmptyRecord();

                incomingTxRecord.setUUIDValue  (CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_ID_COLUMN_NAME          , txId                                    );
                incomingTxRecord.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_HASH_COLUMN_NAME        , txHash                                  );
                incomingTxRecord.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_PROTOCOL_STS_COLUMN_NAME    , ProtocolStatus.TO_BE_NOTIFIED.getCode() );
                incomingTxRecord.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_STS_COLUMN_NAME , CryptoStatus.ON_CRYPTO_NETWORK.getCode());
                incomingTxRecord.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_TYPE_COLUMN_NAME, CryptoTransactionType.INCOMING.getCode());

                cryptoTxTable.insertRecord(incomingTxRecord);

                // after I save the transaction in the database and the vault, I'll raise the incoming transaction.
                FermatEvent event = new IncomingCryptoOnCryptoNetworkEvent(EventType.INCOMING_CRYPTO_ON_CRYPTO_NETWORK);
                event.setSource(EventSource.CRYPTO_VAULT);
                eventManager.raiseEvent(event);
            }

        } catch (CantInsertRecordException e) {

            throw new CantExecuteQueryException("Error trying to persist in saveIncomingTransaction method.", e, "Transaction Hash:" + txHash, "Error in database plugin.");
        } catch (CantLoadTableToMemoryException e) {

            throw new CantExecuteQueryException("Error trying to bring data in saveIncomingTransaction method.", e, "Transaction Hash:" + txHash, "Error in database plugin.");
        } catch(Exception exception){

            throw new CantExecuteQueryException(FermatException.wrapException(exception));
        }
    }

    /**
     * Validates if the transaction ID passed is new or not. This helps to decide If I need to apply the transactions or not
     * @param txId the ID of the transaction
     * @return
     */
    public boolean isNewFermatTransaction(final UUID txId) throws CantExecuteQueryException {

        try {
            DatabaseTable fermatTxTable = database.getTable(CryptoVaultDatabaseConstants.FERMAT_TRANSACTIONS_TABLE_NAME);

            fermatTxTable.setUUIDFilter(CryptoVaultDatabaseConstants.FERMAT_TRANSACTIONS_TABLE_TRX_ID_COLUMN_NAME, txId, DatabaseFilterType.EQUAL);

            fermatTxTable.loadToMemory();

            // If we couldn't find a record with this transaction id, then we consider it like a new transaction.
            return fermatTxTable.getRecords().isEmpty();

        } catch (CantLoadTableToMemoryException cantLoadTableToMemory) {

            throw new CantExecuteQueryException("Error validating transaction in DB.", cantLoadTableToMemory, "Transaction Id:" + txId, "Error in database plugin.");
        } catch(Exception exception){

            throw new CantExecuteQueryException(FermatException.wrapException(exception));
        }
    }

    // returns type of transaction having i count if already exists, if not by default returns incoming
    public CryptoTransactionType calculateTransactionType(final String txHash) throws CantExecuteQueryException {

        try {
            DatabaseTable fermatTxTable = database.getTable(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_NAME);

            fermatTxTable.setStringFilter(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_HASH_COLUMN_NAME, txHash, DatabaseFilterType.EQUAL);

            fermatTxTable.loadToMemory();

            // if i don't find records, i think is a new incoming transaction, if i find, y return the type of transaction it is.
            if (fermatTxTable.getRecords().isEmpty())
                return CryptoTransactionType.INCOMING;
            else
                return CryptoTransactionType.getByCode(fermatTxTable.getRecords().get(0).getStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_TYPE_COLUMN_NAME));

        } catch (CantLoadTableToMemoryException cantLoadTableToMemory) {

            throw new CantExecuteQueryException("Error validating transaction in DB.", cantLoadTableToMemory, "Transaction HASH:" + txHash, "Error in database plugin.");
        } catch (InvalidParameterException invalidParameterException) {

            throw new CantExecuteQueryException("Error with transaction type code.", invalidParameterException, "Transaction HASH:" + txHash, "Error in database plugin.");
        } catch(Exception exception){

            throw new CantExecuteQueryException(FermatException.wrapException(exception));
        }
    }

    /**
     * Throw this methods we can persist a new crypto transaction generated by our wallet.
     * By default in an outgoing transaction we assign the following values:
     * type           : OUTGOING           - outgoing transaction (generated by our wallet).
     * crypto status  : ON_CRYPTO_NETWORK  - we generate the transaction directly in ON_CRYPTO_NETWORK status.
     * protocol status: NO_ACTION_REQUIRED - because the transaction is generated by our wallet we don't need to inform it.
     */
    public  void persistNewTransaction(final String txId  ,
                                       final String txHash) throws CantExecuteQueryException {

        try {

            DatabaseTable cryptoTxTable = database.getTable(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_NAME);

            DatabaseTableRecord incomingTxRecord =  cryptoTxTable.getEmptyRecord();

            ProtocolStatus        protocolStatus  = ProtocolStatus       .NO_ACTION_REQUIRED;
            CryptoStatus          cryptoStatus    = CryptoStatus         .ON_CRYPTO_NETWORK ;
            CryptoTransactionType transactionType = CryptoTransactionType.OUTGOING          ;

            incomingTxRecord.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_ID_COLUMN_NAME          , txId                     );
            incomingTxRecord.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_HASH_COLUMN_NAME        , txHash                   );
            incomingTxRecord.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_PROTOCOL_STS_COLUMN_NAME, protocolStatus.getCode());
            incomingTxRecord.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_STS_COLUMN_NAME, cryptoStatus.getCode());
            incomingTxRecord.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_TYPE_COLUMN_NAME, transactionType.getCode());

            cryptoTxTable.insertRecord(incomingTxRecord);

        } catch (CantInsertRecordException e) {

            throw new CantExecuteQueryException("Error persisting in DB.", e, "Transaction Hash:" + txHash, "Error in database plugin.");
        } catch(Exception exception){

            throw new CantExecuteQueryException(FermatException.wrapException(exception));
        }
    }

    /**
     * Throw this methods we get all the transactions that with ProtocolStatus = TO_BE_NOTIFIED and by
     * parameters we pass the type of transaction that we need.
     *
     * This methods now it's only used with INCOMING transactions, but in the near future maybe we will need
     * to bring OUTGOING transactions too.
     *
     * @return a hashMap string-string in where the key is the transaction id and the value the transaction hash,
     */
    public HashMap<String, String> getPendingTransactionsHeadersByTransactionType(CryptoTransactionType type) throws CantExecuteQueryException {

        try {
            DatabaseTable cryptoTxTable;
            HashMap<String, String> transactionsIds = new HashMap<>();

            cryptoTxTable = database.getTable(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_NAME);

            ProtocolStatus protocolStatus = ProtocolStatus.TO_BE_NOTIFIED;

            cryptoTxTable.setStringFilter(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_PROTOCOL_STS_COLUMN_NAME, protocolStatus.getCode(), DatabaseFilterType.EQUAL);
            cryptoTxTable.setStringFilter(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_TYPE_COLUMN_NAME, type.getCode(), DatabaseFilterType.EQUAL);

            cryptoTxTable.loadToMemory();

             for (DatabaseTableRecord record : cryptoTxTable.getRecords()){
                transactionsIds.put(record.getStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_ID_COLUMN_NAME), record.getStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_HASH_COLUMN_NAME));
             }

            return transactionsIds;

        } catch (CantLoadTableToMemoryException cantLoadTableToMemory) {

            throw new CantExecuteQueryException("Error executing query in DB.", cantLoadTableToMemory, null, "Error in database plugin.");
        } catch(Exception exception){

            throw new CantExecuteQueryException(FermatException.wrapException(exception));
        }
    }

    /**
     * Will update the protocol status of the passed transaction.
     * @param txId
     * @param newStatus
     */
    public void updateTransactionProtocolStatus(final UUID           txId     ,
                                                final ProtocolStatus newStatus) throws CantExecuteQueryException                     ,
                                                                                       UnexpectedResultReturnedFromDatabaseException {

        try {

            DatabaseTable cryptoTxTable;
            cryptoTxTable = database.getTable(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_NAME);

            cryptoTxTable.setUUIDFilter(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_ID_COLUMN_NAME, txId, DatabaseFilterType.EQUAL);

            cryptoTxTable.loadToMemory();

            DatabaseTableRecord toUpdate;

            if (cryptoTxTable.getRecords().size() > 1)
                throw new UnexpectedResultReturnedFromDatabaseException("Unexpected result. More than value returned.", null, "Txid:" + txId+ " Protocol Status:" + newStatus.toString(), "duplicated Transaction Id.");
            else {
                toUpdate = cryptoTxTable.getRecords().get(0);
            }

            /**
             * I set the Protocol status to the new value
             */
            toUpdate.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_PROTOCOL_STS_COLUMN_NAME, newStatus.getCode());
            cryptoTxTable.updateRecord(toUpdate);

        } catch (CantUpdateRecordException cantUpdateRecord) {

            throw new CantExecuteQueryException("Error trying yo update a record in DB.", cantUpdateRecord, "TxId " + txId, "Error in database plugin.");
        } catch (CantLoadTableToMemoryException cantLoadTableToMemory) {

            throw new CantExecuteQueryException("Error executing query in DB.", cantLoadTableToMemory, "TxId " + txId, "Error in database plugin.");
        } catch(Exception exception){

            throw new CantExecuteQueryException(FermatException.wrapException(exception));
        }
    }

    /**
     * Gets from database the current CryptoStatus of a specific transaction by fermat transaction id.
     *
     * @param txId fermat transaction id
     *
     * @return an element of the crypto status enum representing the status of the transaction.
     *
     * @throws CantExecuteQueryException                       if something goes wrong.
     * @throws UnexpectedResultReturnedFromDatabaseException   if the transaction doesn't exists or is duplicated in database.
     */
    public CryptoStatus getCryptoStatus (final String txId) throws CantExecuteQueryException                     ,
                                                                   UnexpectedResultReturnedFromDatabaseException {

        try {
            DatabaseTable cryptoTxTable = database.getTable(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_NAME);

            cryptoTxTable.setStringFilter(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_ID_COLUMN_NAME, txId, DatabaseFilterType.EQUAL);

            cryptoTxTable.loadToMemory();

            // will make sure I only get one result.
            if (cryptoTxTable.getRecords().size() > 1)
                throw new UnexpectedResultReturnedFromDatabaseException("Unexpected result. More than value returned.", null, "TxId:" + txId, "duplicated Transaction Id.");
            else if (cryptoTxTable.getRecords().isEmpty())
                throw new UnexpectedResultReturnedFromDatabaseException("No values returned when trying to get CryptoStatus from transaction in database.", null, "TxId:" + txId, "transaction not yet persisted in database.");
            else
                return CryptoStatus.getByCode(cryptoTxTable.getRecords().get(0).getStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_STS_COLUMN_NAME));

        } catch (UnexpectedResultReturnedFromDatabaseException e) {

            throw e;
        } catch (CantLoadTableToMemoryException cantLoadTableToMemory) {

            throw new CantExecuteQueryException("Error executing query in DB.", cantLoadTableToMemory, "TxId " + txId, "Error in database plugin.");
        } catch(Exception exception){

            throw new CantExecuteQueryException(FermatException.wrapException(exception));
        }
    }

    //We will ask if exists pending transactions to be notified with the passed cryptoStatus and type passed by parameter.
    public boolean isPendingTransactions(final CryptoStatus          cryptoStatus,
                                         final CryptoTransactionType type        ) throws CantExecuteQueryException {

        try {
            DatabaseTable cryptoTxTable = database.getTable(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_NAME);

            ProtocolStatus protocolStatus = ProtocolStatus.TO_BE_NOTIFIED;

            cryptoTxTable.setStringFilter(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_PROTOCOL_STS_COLUMN_NAME    , protocolStatus.getCode() , DatabaseFilterType.EQUAL);
            cryptoTxTable.setStringFilter(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_STS_COLUMN_NAME, cryptoStatus.getCode(), DatabaseFilterType.EQUAL);
            cryptoTxTable.setStringFilter(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_TYPE_COLUMN_NAME, type          .getCode() , DatabaseFilterType.EQUAL);

            cryptoTxTable.loadToMemory();

            return !cryptoTxTable.getRecords().isEmpty();

        } catch (CantLoadTableToMemoryException cantLoadTableToMemory) {

            throw new CantExecuteQueryException("Error executing query in DB.", cantLoadTableToMemory, null, "Error in database plugin.");
        }catch(Exception exception){

            throw new CantExecuteQueryException(FermatException.wrapException(exception));
        }
    }

    //We will ask if exists pending transactions to be notified
    public List<TransactionTypeAndCryptoStatus> listTransactionTypeAndCryptoStatusToBeNotified( ) throws CantExecuteQueryException {

        try {
            DatabaseTable cryptoTxTable = database.getTable(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_NAME);

            ProtocolStatus protocolStatus = ProtocolStatus.TO_BE_NOTIFIED;

            String query = "SELECT "+
                    CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_TYPE_COLUMN_NAME +
                    ", " +
                    CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_STS_COLUMN_NAME +
                    " FROM " +
                    CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_NAME +
                    " WHERE " +
                    CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_PROTOCOL_STS_COLUMN_NAME +
                    " = '" +
                    protocolStatus.getCode() +
                    "' GROUP BY " +
                    CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_TYPE_COLUMN_NAME +
                    ", " +
                    CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_STS_COLUMN_NAME;

            List<DatabaseTableRecord> records = cryptoTxTable.customQuery(query, true);

            if(!records.isEmpty()) {
                List<TransactionTypeAndCryptoStatus> list = new ArrayList<>();

                for (DatabaseTableRecord record : records) {

                    CryptoTransactionType transactionType = CryptoTransactionType.getByCode(record.getStringValue("Column0"));
                    CryptoStatus          cryptoStatus    = CryptoStatus         .getByCode(record.getStringValue("Column1"));

                    list.add(new TransactionTypeAndCryptoStatus(transactionType, cryptoStatus));
                }

                return list;
            } else {
                return new ArrayList<>();
            }

        } catch (InvalidParameterException e) {

            throw new CantExecuteQueryException(e, null, "Error in the data of the records.");
        } catch (CantLoadTableToMemoryException cantLoadTableToMemory) {

            throw new CantExecuteQueryException("Error executing query in DB.", cantLoadTableToMemory, null, "Error in database plugin.");
        } catch(Exception exception){

            throw new CantExecuteQueryException(FermatException.wrapException(exception));
        }
    }

    public boolean transactionExists(String txHash, CryptoStatus cryptoStatus) throws CantExecuteQueryException {
        try {
            DatabaseTable cryptoTxTable = database.getTable(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_NAME);

            cryptoTxTable.setStringFilter(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_HASH_COLUMN_NAME       , txHash                 , DatabaseFilterType.EQUAL);
            cryptoTxTable.setStringFilter(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_STS_COLUMN_NAME, cryptoStatus.getCode() , DatabaseFilterType.EQUAL);

            cryptoTxTable.loadToMemory();

            return !cryptoTxTable.getRecords().isEmpty();

        } catch (CantLoadTableToMemoryException cantLoadTableToMemory) {
            throw new CantExecuteQueryException("Error executing query in DB.", cantLoadTableToMemory, null, "Error in database plugin.");
        }catch(Exception exception){
            throw new CantExecuteQueryException(FermatException.wrapException(exception));
        }
    }


    /**
     * increase by one or resets to zero the counter of transactions found ready to be consumed
     * @param newOcurrence
     * @return the amount of iterations
     * @throws CantExecuteQueryException
     */
    public int updateTransactionProtocolStatus(boolean newOcurrence) throws CantExecuteQueryException {
        try {
            DatabaseTable transactionProtocolStatusTable = database.getTable(CryptoVaultDatabaseConstants.TRANSITION_PROTOCOL_STATUS_TABLE_NAME);

            transactionProtocolStatusTable.loadToMemory();

            List<DatabaseTableRecord> records = transactionProtocolStatusTable.getRecords();

            if (records.isEmpty()) {
                /**
                 * there are no records, I will insert the first one that will be always updated
                 */
                long timestamp = System.currentTimeMillis() / 1000L;
                DatabaseTableRecord emptyRecord = transactionProtocolStatusTable.getEmptyRecord();

                emptyRecord.setLongValue(CryptoVaultDatabaseConstants.TRANSITION_PROTOCOL_STATUS_TABLE_TIMESTAMP_COLUMN_NAME, timestamp);
                emptyRecord.setIntegerValue(CryptoVaultDatabaseConstants.TRANSITION_PROTOCOL_STATUS_TABLE_OCURRENCES_COLUMN_NAME, 0);

                transactionProtocolStatusTable.insertRecord(emptyRecord);

                /**
                 * returns 1
                 */
                return 0;
            }

            DatabaseTableRecord record = records.get(0);

            if (newOcurrence) {
                /**
                 * I need to increase the ocurrences counter by one
                 */
                int ocurrence = record.getIntegerValue(CryptoVaultDatabaseConstants.TRANSITION_PROTOCOL_STATUS_TABLE_OCURRENCES_COLUMN_NAME);
                ocurrence++;
                record.setIntegerValue(CryptoVaultDatabaseConstants.TRANSITION_PROTOCOL_STATUS_TABLE_OCURRENCES_COLUMN_NAME, ocurrence);

                transactionProtocolStatusTable.updateRecord(record);

                return ocurrence;

            } else {
                /**
                 * I need to reset the counter to 0
                 */
                record.setIntegerValue(CryptoVaultDatabaseConstants.TRANSITION_PROTOCOL_STATUS_TABLE_OCURRENCES_COLUMN_NAME, 0);
                transactionProtocolStatusTable.updateRecord(record);

                return 0;

            }
            //
        } catch (CantInsertRecordException e) {

            throw new CantExecuteQueryException("Error trying to insert in DB.", e, null, "Error in database plugin.");
        } catch (CantUpdateRecordException e) {

            throw new CantExecuteQueryException("Error trying to update in DB.", e, null, "Error in database plugin.");
        } catch (CantLoadTableToMemoryException cantLoadTableToMemory) {

            throw new CantExecuteQueryException("Error executing query in DB.", cantLoadTableToMemory, null, "Error in database plugin.");
        } catch(Exception exception){

            throw new CantExecuteQueryException(FermatException.wrapException(exception));
        }
    }

    /**
     * Insert a new Fermat transaction in the database
     * @param txId
     * @throws CantExecuteQueryException
     */
    public void persistnewFermatTransaction(final String txId) throws CantExecuteQueryException {

        try {
            DatabaseTable fermatTable;
            fermatTable = database.getTable(CryptoVaultDatabaseConstants.FERMAT_TRANSACTIONS_TABLE_NAME);

            DatabaseTableRecord insert = fermatTable.getEmptyRecord();

            insert.setStringValue(CryptoVaultDatabaseConstants.FERMAT_TRANSACTIONS_TABLE_TRX_ID_COLUMN_NAME, txId);

            fermatTable.insertRecord(insert);

        } catch (CantInsertRecordException e) {

            throw new CantExecuteQueryException("Error executing query in DB.", e, "TxId: " + txId, "Error in database plugin.");
        } catch(Exception exception){

            throw new CantExecuteQueryException(FermatException.wrapException(exception));
        }
    }

    public CryptoStatus getLastCryptoStatus(final String txHash) throws CantLoadTableToMemoryException, InvalidParameterException {

        DatabaseTable cryptoTransactionsTable = database.getTable(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_NAME);

        cryptoTransactionsTable.setStringFilter(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_HASH_COLUMN_NAME, txHash, DatabaseFilterType.EQUAL);
        cryptoTransactionsTable.loadToMemory();

        List<DatabaseTableRecord> databaseTableRecordList = cryptoTransactionsTable.getRecords();
        if (databaseTableRecordList.isEmpty()) {
            return null;
        } else {
            CryptoStatus lastCryptoStatus = null;
            for (DatabaseTableRecord record : databaseTableRecordList) {
                CryptoStatus cryptoStatus = CryptoStatus.getByCode(record.getStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_STS_COLUMN_NAME));
                if (lastCryptoStatus == null)
                    lastCryptoStatus = cryptoStatus;
                else if (lastCryptoStatus.getOrder() < cryptoStatus.getOrder())
                    lastCryptoStatus = cryptoStatus;
            }
            return lastCryptoStatus;
        }
    }

    /**
     * Insert a new transaction with the confidence level or update the cryptoStatus of an existing transaction.
     */
    public void insertNewTransactionWithNewConfidence(final String                hashAsString,
                                                      final CryptoStatus          cryptoStatus,
                                                      final CryptoTransactionType type        ) throws CantExecuteQueryException {


        try {

            DatabaseTable cryptoTxTable = database.getTable(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_NAME);
            DatabaseTableRecord record = cryptoTxTable.getEmptyRecord();

            // new values to assign
            UUID           newFermatId    = UUID.randomUUID()            ;
            ProtocolStatus protocolStatus = ProtocolStatus.TO_BE_NOTIFIED;

            record.setUUIDValue  (CryptoVaultDatabaseConstants.FERMAT_TRANSACTIONS_TABLE_TRX_ID_COLUMN_NAME          , newFermatId             );
            record.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRX_HASH_COLUMN_NAME        , hashAsString            );
            record.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_PROTOCOL_STS_COLUMN_NAME    , protocolStatus.getCode());
            record.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_STS_COLUMN_NAME , cryptoStatus  .getCode());
            record.setStringValue(CryptoVaultDatabaseConstants.CRYPTO_TRANSACTIONS_TABLE_TRANSACTION_TYPE_COLUMN_NAME, type          .getCode());

            DatabaseTransaction dbTran = database.newTransaction();
            dbTran.addRecordToInsert(cryptoTxTable, record);

            database.executeTransaction(dbTran);

        } catch (DatabaseTransactionFailedException e) {

            throw new CantExecuteQueryException(e, "Transaction Hash:" + hashAsString + " CryptoStatus:" + cryptoStatus.toString(), "Error in database plugin inserting new transaction when the transaction confidence changed.");
        } catch(Exception exception){

            throw new CantExecuteQueryException(exception);
        }
    }
}
